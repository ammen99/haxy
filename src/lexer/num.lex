number   : /-?[0-9]+/ ;
dbl      : /-?[0-9]+[.][0-9]+/ ;
bool     : "true" | "false" ;
op1      : "&&" | "||" | "**" ;
op2      : "==" | "<=" | ">=" | "<" | ">" | "!=";
op3      : "*" | "/" | "%" ;
op4      : '+' | '-' ;
ident    : /[a-zA-Z_][a-zA-Z0-9_]*/ ;
noarg    : "" ;
args     : (<expr> ',')* <expr> | <noarg> ;
func     : <ident> '(' <args> ')' ;
value    : <member> | <gcomp> | <listq> | <str> | <func> | <dbl> | <number> | <bool> | <ident> | <list> | '(' <operator> <expr>+ ')' ;

comp1    : (<comp2> | <comp3> | <comp4> | <value>) <op1> (<comp2> | <comp3> | <comp4> | <value>)  ;
comp     : <expr> <op1> <expr> | <expr> <op2> <expr> | <expr> <op3> <expr> | <expr> <op4> <expr> ;

comp     : <comp1> | <comp2> | <comp3> | <comp4> ;
gcomp    : '(' <comp> ')' ;
expr     : <comp> | <value> ;
assign   : (<listq> | <ident> | <member>) '=' <expr> ;
var      : "var" (<assign> | <ident>) (',' (<assign> | <ident>))* ';' ;
list     : '[' <args> ']' ;
str      : /\"(\\\\.|[^\"])*\"/ ;
state    : <return> | <var> | <assign> ';' | <listq> | <func> ';' | <member> ';' | <cond> | <while> ;
if       : "if" <gcomp> <body> ;
elif     : "elif" <gcomp> <body> ;
else     : "else" <body> ;
cond     : <if> <elif>* <else>* ;
while    : "while" <gcomp> <body> ;
body     : '{' <state>* '}' ;
fundef   : "def" <func> <body> ;
class    : "class" <ident> '{' (<var> | <fundef>)* '}' ;
memtype  : <func> | <listq> | <ident> ;
member   : <memtype> ('@' <memtype>)+ ;
toplvl : <class> | <fundef> | <state> | <comp> | <list> | <expr> ;
lispy    : /^/ <toplvl>* /$/ ;
listq    : <ident> ('[' <expr> ']')+ ;
return   : "return" <expr> ';' ;
